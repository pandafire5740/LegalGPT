<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LegalGPT</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>‚öñÔ∏è</text></svg>">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <link href="/static/styles.css?v=1760559005" rel="stylesheet">
</head>
<body>
    <div class="app-container">
        <!-- Header -->
        <header class="app-header">
            <div class="header-content">
                <div class="logo" onclick="reloadPage()" title="Click to reload page">
                    <i class="fas fa-scale-balanced"></i>
                    <h1>LegalGPT</h1>
                </div>
                
                <!-- Mode Toggle -->
                <div class="mode-toggle">
                    <button class="mode-btn active" data-mode="chat" onclick="switchMode('chat')">
                        <i class="fas fa-comments"></i>
                        Chat
                    </button>
                    <button class="mode-btn" data-mode="search" onclick="switchMode('search')">
                        <i class="fas fa-search"></i>
                        Search
                    </button>
                    <button class="mode-btn" data-mode="extract" onclick="switchMode('extract')">
                        <i class="fas fa-file-contract"></i>
                        Extract
                    </button>
                </div>
                
                <!-- Theme Control - Centered between mode-toggle and header-stats -->
                <div class="theme-toggle" title="Toggle light/dark" onclick="toggleTheme()">
                    <div class="theme-track">
                        <div class="theme-thumb">
                            <i class="fas fa-sun"></i>
                            <i class="fas fa-moon"></i>
                        </div>
                    </div>
                </div>
                
                <div class="header-stats">
                    <div class="stat-item tooltip-host">
                        <span class="stat-value" id="document-count">-</span>
                        <span class="stat-label">Documents</span>
                        <div class="doc-tooltip" id="doc-tooltip"></div>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="chunk-count">-</span>
                        <span class="stat-label">Sections</span>
                    </div>
                </div>
            </div>
        </header>

        <!-- Main Content -->
        <main class="main-content">
            <!-- Sidebar -->
            <aside class="sidebar">
                <!-- Prompt Templates Section -->
                <!-- Prompt templates removed in minimal build -->
                
                <div class="sidebar-section">
                    <h3><i class="fas fa-folder-open"></i> Document Management</h3>
                    <button class="action-btn" onclick="showDocumentUpload()">
                        <i class="fas fa-upload"></i>
                        Upload Local Documents
                    </button>
                    <button class="action-btn" onclick="showManageFiles()">
                        <i class="fas fa-cog"></i>
                        Manage Local Files
                    </button>
                </div>

                <div class="sidebar-section">
                    <h3><i class="fas fa-question-circle"></i> Example Questions</h3>
                    <div class="example-queries">
                        <div class="query-example" onclick="sendExampleQuery(this)">
                            "Show me all contracts with termination clauses"
                        </div>
                        <div class="query-example" onclick="sendExampleQuery(this)">
                            "Extract payment terms from vendor agreements"
                        </div>
                        <div class="query-example" onclick="sendExampleQuery(this)">
                            "Find documents mentioning confidentiality"
                        </div>
                        <div class="query-example" onclick="sendExampleQuery(this)">
                            "Summarize the contract with Playlist DataTrust DPA"
                        </div>
                    </div>
                </div>

                <div class="sidebar-section">
                    <h3><i class="fas fa-chart-bar"></i> System Status</h3>
                    <div class="status-indicator">
                        <span class="status-dot" id="sharepoint-status"></span>
                        Sharepoint Connection
                    </div>
                    <div class="status-indicator">
                        <span class="status-dot" id="vector-status"></span>
                        Vector Database
                    </div>
                </div>
            </aside>

            <!-- Mode Content Container -->
            <div class="mode-content">
                <!-- Chat Mode -->
                <div class="mode-panel active" id="chat-mode">
                <div class="chat-messages" id="chat-messages">
                    <div class="welcome-message">
                        <div class="message-content">
                            <h2>üëã Welcome to LegalGPT</h2>
                            <p>I'm your AI assistant for legal document search and analysis. I can help you:</p>
                            <ul>
                                <li>Find specific information in contracts and legal documents</li>
                                <li>Extract terms and conditions from agreements</li>
                                <li>Summarize document content</li>
                                <li>Locate files in your Sharepoint repository</li>
                                <li>Answer questions about legal clauses and provisions</li>
                            </ul>
                            <p><strong>Ask me anything about your legal documents!</strong></p>
                        </div>
                    </div>
                </div>

                <div class="chat-input-container">
                        
                        
                    <div class="input-wrapper">
                        <div class="autocomplete-container">
                            <textarea 
                                id="chat-input" 
                                placeholder="Ask about your legal documents..."
                                rows="1"
                                onkeydown="handleChatInputKeyDown(event)"
                                oninput="handleChatInputChange(event)"
                                onfocus="handleChatInputFocus(event)"
                                onblur="handleChatInputBlur(event)"
                            ></textarea>
                            <div class="autocomplete-dropdown" id="autocomplete-dropdown"></div>
                        </div>
                        <button id="send-button" onclick="sendMessage()">
                            <i class="fas fa-paper-plane"></i>
                        </button>
                    </div>
                    <div class="input-footer">
                        <small>Press Enter to send ‚Ä¢ Shift+Enter for new line ‚Ä¢ Your conversations help improve the system</small>
                        </div>
                    </div>
                </div>

                <!-- Search Mode -->
                <div class="mode-panel" id="search-mode">
                    <div class="search-container">
                        <div class="search-header">
                            <h2><i class="fas fa-search"></i> Document Search</h2>
                            <p>Search across documents using AI-powered search</p>
                            
                            <div class="search-input-container">
                                <div class="input-wrapper">
                                    <input 
                                        type="text" 
                                        id="search-input" 
                                        placeholder="Enter your search query..."
                                        onkeydown="handleSearchKeyDown(event)"
                                    >
                                    <button id="search-button" onclick="performSearch()">
                                        <i class="fas fa-search"></i>
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <div class="search-results" id="search-results">
                            <div class="search-placeholder">
                                <i class="fas fa-search"></i>
                                <p>Enter a search query to find relevant documents</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Extract Mode -->
                <div class="mode-panel" id="extract-mode">
                    <div class="extract-container">
                        <div class="extract-header">
                            <h2><i class="fas fa-file-contract"></i> Contract Extraction</h2>
                            <p>Select a file from memory to extract key terms using AI</p>
                            
                            <div class="extract-selector-area">
                                <div class="file-selector-box">
                                    <label for="extract-file-select">
                                        <i class="fas fa-folder-open"></i> Select File from Memory
                                    </label>
                                    <select id="extract-file-select" class="file-dropdown">
                                        <option value="">-- Choose a file --</option>
                                    </select>
                                    <button class="extract-btn" onclick="extractTermsFromMemory()">
                                        <i class="fas fa-magic"></i>
                                        Extract Terms
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <div class="extract-results" id="extract-results">
                            <div class="extract-placeholder">
                                <i class="fas fa-file-contract"></i>
                                <p>Select a file and click "Extract Terms" to analyze</p>
                            </div>
                        </div>
                        
                        <div class="extract-actions" id="extract-actions" style="display: none;">
                            <button class="action-btn" onclick="exportExtractionResults()">
                                <i class="fas fa-download"></i>
                                Export CSV
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </main>

        <!-- Loading Overlay -->
        <div class="loading-overlay" id="loading-overlay">
            <div class="loading-spinner">
                <i class="fas fa-spinner fa-spin"></i>
                <p>LegalGPT is generating a response...</p>
            </div>
        </div>

        <!-- Modal for Terms Extraction -->
        <div class="modal" id="terms-modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h3><i class="fas fa-file-contract"></i> Extract Terms & Conditions</h3>
                    <button class="modal-close" onclick="closeModal('terms-modal')">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <label for="terms-filter">Filter by contract type (optional):</label>
                        <input type="text" id="terms-filter" placeholder="e.g., service agreement, employment, vendor">
                    </div>
                    <button class="btn btn-primary" onclick="extractTerms()">
                        <i class="fas fa-extract"></i>
                        Extract Terms
                    </button>
                </div>
            </div>
        </div>

        <!-- Modal for Document Search -->
        <div class="modal" id="search-modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h3><i class="fas fa-search"></i> Find Document Location</h3>
                    <button class="modal-close" onclick="closeModal('search-modal')">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <label for="document-query">Document name or description:</label>
                        <input type="text" id="document-query" placeholder="e.g., contract with ABC Corp, NDA, employment agreement">
                    </div>
                    <button class="btn btn-primary" onclick="findDocument()">
                        <i class="fas fa-search"></i>
                        Find Document
                    </button>
                </div>
            </div>
        </div>

        <!-- Modal for Manage Files -->
        <div class="modal" id="manage-files-modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h3><i class="fas fa-folder-open"></i> Manage Local Files</h3>
                    <button class="modal-close" onclick="closeModal('manage-files-modal')">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="modal-body">
                    <div id="files-list-container">
                        <div class="loading-message">Loading files...</div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="clear-btn" onclick="resetIndex()" title="Clear all files and reset counters">
                        <i class="fas fa-rotate"></i>
                        Clear All Files
                    </button>
                </div>
            </div>
        </div>

        <!-- Modal for Document Upload -->
        <div class="modal" id="upload-modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h3><i class="fas fa-upload"></i> Upload Local Documents</h3>
                    <button class="modal-close" onclick="closeModal('upload-modal')">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="modal-body">
                    <div class="form-group">
                        <label for="file-upload">Select documents to upload:</label>
                        <input type="file" id="file-upload" multiple accept=".pdf,.docx,.doc,.txt,.rtf">
                        <small>Supported formats: PDF, DOCX, DOC, TXT, RTF</small>
                    </div>
                    <div class="upload-progress" id="upload-progress" style="display: none;">
                        <div class="progress-bar">
                            <div class="progress-fill" id="progress-fill"></div>
                        </div>
                        <div class="progress-text" id="progress-text">Uploading...</div>
                    </div>
                    <button class="btn btn-primary" onclick="uploadDocuments()">
                        <i class="fas fa-upload"></i>
                        Upload Documents
                    </button>
                </div>
            </div>
        </div>

        <!-- Modal for Prompt Editor -->
        <div class="modal" id="prompt-editor-modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h3><i class="fas fa-magic"></i> Prompt Templates</h3>
                    <button class="modal-close" onclick="closeModal('prompt-editor-modal')">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="modal-body">
                    <div class="prompt-editor">
                        <div class="prompt-list" id="prompt-list">
                            <!-- Templates will be loaded here -->
                        </div>
                        <div class="prompt-actions">
                            <button class="btn btn-secondary" onclick="addNewPrompt()">
                                <i class="fas fa-plus"></i>
                                Add Template
                            </button>
                            <button class="btn btn-primary" onclick="savePrompts()">
                                <i class="fas fa-save"></i>
                                Save Changes
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Fallback functions in case app.js fails to load
        function showDocumentUpload() {
            console.log('Fallback showDocumentUpload called');
            const modal = document.getElementById('upload-modal');
            if (modal) {
                // Reset modal state
                const fileInput = document.getElementById('file-upload');
                const progressDiv = document.getElementById('upload-progress');
                const progressFill = document.getElementById('progress-fill');
                const progressText = document.getElementById('progress-text');
                
                if (fileInput) fileInput.value = '';
                if (progressDiv) progressDiv.style.display = 'none';
                if (progressFill) progressFill.style.width = '0%';
                if (progressText) progressText.textContent = 'Uploading...';
                
                modal.classList.add('active');
                console.log('Modal activated via fallback');
            }
        }
        
        async function uploadDocuments() {
            console.log('Fallback uploadDocuments called');
            const fileInput = document.getElementById('file-upload');
            const files = fileInput.files;
            
            if (files.length === 0) {
                alert('Please select at least one file to upload.');
                return;
            }

            const progressDiv = document.getElementById('upload-progress');
            const progressFill = document.getElementById('progress-fill');
            const progressText = document.getElementById('progress-text');
            let warningsDiv = document.getElementById('upload-warnings');
            if (!warningsDiv) {
                warningsDiv = document.createElement('div');
                warningsDiv.id = 'upload-warnings';
                warningsDiv.style.marginTop = '0.5rem';
                warningsDiv.style.fontSize = '0.875rem';
                warningsDiv.style.color = 'var(--warning-color)';
                progressDiv.parentElement.appendChild(warningsDiv);
            } else {
                warningsDiv.textContent = '';
            }
            
            progressDiv.style.display = 'block';
            
            let uploadedCount = 0;
            const totalFiles = files.length;
            let duplicateNames = [];

            // Client-side dedupe using current stats
            try {
                const statsRes = await fetch('/api/documents/stats/simple');
                const stats = await statsRes.json();
                const existing = new Set(Array.isArray(stats.files) ? stats.files : []);
                const filtered = [];
                for (let i = 0; i < files.length; i++) {
                    if (existing.has(files[i].name)) {
                        duplicateNames.push(files[i].name);
                    } else {
                        filtered.push(files[i]);
                    }
                }
                if (duplicateNames.length) {
                    warningsDiv.textContent = `We already have this file in memory! ${duplicateNames.join(', ')}`;
                }
                files = filtered;
            } catch (e) {}
            
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                
                try {
                    progressText.textContent = `Uploading ${file.name}... (${i + 1}/${totalFiles})`;
                    
                    const formData = new FormData();
                    formData.append('file', file);
                    
                    const response = await fetch('/api/documents/upload', {
                        method: 'POST',
                        body: formData
                    });
                    
                    const result = await response.json();
                    
                    if (result.status === 'success') {
                        uploadedCount++;
                        console.log(`‚úÖ Successfully uploaded "${file.name}"`);
                    } else if (result.status === 'exists') {
                        duplicateNames.push(file.name);
                        warningsDiv.textContent = `We already have this file in memory! ${duplicateNames.join(', ')}`;
                    } else {
                        console.log(`‚ùå Failed to upload "${file.name}": ${result.detail || 'Unknown error'}`);
                    }
                    
                    // Update progress
                    const progress = ((i + 1) / totalFiles) * 100;
                    progressFill.style.width = `${progress}%`;
                    
                } catch (error) {
                    console.error('Upload error:', error);
                }
            }
            
            progressText.textContent = `Upload complete! ${uploadedCount}/${totalFiles} files uploaded successfully.`;
            
            // Refresh document counter
            updateDocumentCounter();
            
            // Close modal after a delay
            setTimeout(() => {
                const modal = document.getElementById('upload-modal');
                modal.classList.remove('active');
                progressDiv.style.display = 'none';
                fileInput.value = '';
                
                // Reset progress bar
                progressFill.style.width = '0%';
                progressText.textContent = 'Uploading...';
            }, 2000);
        }
        
        function closeModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.classList.remove('active');
            }
        }

        function showManageFiles() {
            if (typeof app !== 'undefined' && app) {
                app.showManageFiles();
            }
        }
        
        async function updateDocumentCounter() {
            try {
                const response = await fetch('/api/documents/stats/simple');
                const data = await response.json();
                
                if (data.status === 'success') {
                    const documentCountElement = document.getElementById('document-count');
                    const chunkCountElement = document.getElementById('chunk-count');
                    
                    if (documentCountElement) {
                        documentCountElement.textContent = data.document_count;
                        const files = Array.isArray(data.files) ? data.files : [];
                        const tooltip = document.getElementById('doc-tooltip');
                        if (tooltip) {
                            if (!files.length) {
                                tooltip.innerHTML = '<h4>No files in memory</h4>';
                            } else {
                                const list = files.map(f => `<li>${f.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')}</li>`).join('');
                                tooltip.innerHTML = `<h4>Files in memory (${files.length})</h4><ul>${list}</ul>`;
                            }
                        }
                    }
                    if (chunkCountElement) {
                        chunkCountElement.textContent = data.chunk_count;
                    }
                    
                    console.log('Document counter updated:', data);
                }
            } catch (error) {
                console.error('Failed to update document counter:', error);
            }
        }
        
        // Make functions available globally
        window.showDocumentUpload = showDocumentUpload;
        window.uploadDocuments = uploadDocuments;
        window.closeModal = closeModal;
        window.updateDocumentCounter = updateDocumentCounter;
        
        // Update counter on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize theme from localStorage or prefers-color-scheme
            const savedTheme = localStorage.getItem('theme');
            const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
            const theme = savedTheme || (prefersDark ? 'dark' : 'light');
            document.body.classList.toggle('theme-dark', theme === 'dark');
            updateThemeThumb();

            updateDocumentCounter();
            loadPromptTemplates();
        });

        function toggleTheme() {
            const isDark = document.body.classList.toggle('theme-dark');
            localStorage.setItem('theme', isDark ? 'dark' : 'light');
            updateThemeThumb();
        }

        function updateThemeThumb() {
            const thumb = document.querySelector('.theme-thumb');
            if (!thumb) return;
            const isDark = document.body.classList.contains('theme-dark');
            thumb.classList.toggle('dark', isDark);
        }

        async function resetIndex() {
            if (!confirm('This will clear all indexed chunks and reset counters. Continue?')) return;
            try {
                const res = await fetch('/api/documents/reset', { method: 'POST' });
                const data = await res.json();
                if (data.status === 'success') {
                    // Reset chat area to the original welcome message and update counters
                    const messages = document.getElementById('chat-messages');
                    if (messages) {
                        messages.innerHTML = `
                    <div class="welcome-message">
                        <div class="message-content">
                            <h2>üëã Welcome to LegalGPT</h2>
                            <p>I'm your AI assistant for legal document search and analysis. I can help you:</n+                            </p>
                            <ul>
                                <li>Find specific information in contracts and legal documents</li>
                                <li>Extract terms and conditions from agreements</li>
                                <li>Summarize document content</li>
                                <li>Locate files in your Sharepoint repository</li>
                                <li>Answer questions about legal clauses and provisions</li>
                            </ul>
                            <p><strong>Ask me anything about your legal documents!</strong></p>
                        </div>
                    </div>`;
                    }
                    updateDocumentCounter();
                    alert('Index reset completed.');
                } else {
                    alert('Reset failed.');
                }
            } catch (e) {
                console.error('Reset error', e);
                alert('Reset failed. Check server logs.');
            }
        }
        
        // Expose for other scripts if needed
        window.toggleTheme = toggleTheme;
        window.resetIndex = resetIndex;
        
        // Logo reload function with animation
        function reloadPage() {
            const logo = document.querySelector('.logo');
            if (logo) {
                // Remove any existing animation class first
                logo.classList.remove('animating');
                // Force reflow to ensure class removal is processed
                void logo.offsetWidth;
                // Add animating class to trigger rotation
                logo.classList.add('animating');
                // Wait for full animation (800ms) before reloading
                setTimeout(() => {
                    window.location.reload();
                }, 850); // Slightly longer than animation duration
            } else {
                window.location.reload();
            }
        }
        window.reloadPage = reloadPage;

        // Autocomplete input handlers
        function handleChatInputKeyDown(event) {
            const input = event.target;
            
            // Handle autocomplete navigation
            if (app.autocompleteVisible) {
                if (event.key === 'ArrowDown') {
                    event.preventDefault();
                    app.navigateAutocomplete('down');
                    return false;
                } else if (event.key === 'ArrowUp') {
                    event.preventDefault();
                    app.navigateAutocomplete('up');
                    return false;
                } else if (event.key === 'Enter' && !event.shiftKey && !event.ctrlKey && !event.metaKey) {
                    if (app.selectedSuggestionIndex >= 0) {
                        event.preventDefault();
                        app.selectAutocompleteSuggestion(app.selectedSuggestionIndex);
                        return false;
                    }
                } else if (event.key === 'Escape') {
                    event.preventDefault();
                    app.hideAutocomplete();
                    return false;
                }
            }
            
            // Original Enter key handler for sending messages
            if (event.key === 'Enter' && !event.shiftKey && !event.ctrlKey && !event.metaKey) {
                if (!app.autocompleteVisible || app.selectedSuggestionIndex < 0) {
                    event.preventDefault();
                    sendMessage();
                    return false;
                }
            }
        }

        function handleChatInputChange(event) {
            const input = event.target;
            const query = input.value; // Don't trim - we want to match fragments in the middle
            
            // Auto-resize textarea
            if (typeof app !== 'undefined' && app) {
                app.autoResizeTextarea(event);
            }
            
            // Show autocomplete if query is long enough (3+ characters, after trimming for length check)
            const trimmedQuery = query.trim();
            if (trimmedQuery.length >= 3) {
                const suggestions = app.getAutocompleteSuggestions(query); // Pass full query with spaces
                console.log('handleChatInputChange - query:', query, 'suggestions:', suggestions.length);
                if (suggestions.length > 0) {
                    app.showAutocomplete(suggestions, trimmedQuery); // Use trimmed for highlighting
                } else {
                    app.hideAutocomplete();
                }
            } else {
                app.hideAutocomplete();
            }
        }

        function handleChatInputFocus(event) {
            const input = event.target;
            const query = input.value.trim();
            
            // Show autocomplete if there's text and suggestions (3+ characters)
            if (query.length >= 3) {
                const suggestions = app.getAutocompleteSuggestions(query);
                if (suggestions.length > 0) {
                    app.showAutocomplete(suggestions, query);
                }
            }
        }

        function handleChatInputBlur(event) {
            // Delay hiding to allow clicks on suggestions
            setTimeout(() => {
                const activeElement = document.activeElement;
                if (activeElement !== event.target && 
                    !activeElement?.closest('.autocomplete-dropdown') &&
                    activeElement?.id !== 'chat-input') {
                    app.hideAutocomplete();
                }
            }, 200);
        }

        // Expose handlers globally
        window.handleChatInputKeyDown = handleChatInputKeyDown;
        window.handleChatInputChange = handleChatInputChange;
        window.handleChatInputFocus = handleChatInputFocus;
        window.handleChatInputBlur = handleChatInputBlur;

        // LegalGPT Mode Switching
        function switchMode(mode) {
            // Update mode buttons
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-mode="${mode}"]`).classList.add('active');
            
            // Update mode panels
            document.querySelectorAll('.mode-panel').forEach(panel => {
                panel.classList.remove('active');
            });
            document.getElementById(`${mode}-mode`).classList.add('active');
            
            console.log(`Switched to ${mode} mode`);

            // Align chat height to sidebar when entering chat
            if (typeof app !== 'undefined' && mode === 'chat' && app.syncChatHeightToSidebar) {
                app.syncChatHeightToSidebar();
            }

            // Load files for Extract mode
            if (mode === 'extract') {
                loadExtractFiles();
            }
        }

        // Load files into Extract dropdown
        async function loadExtractFiles() {
            try {
                const response = await fetch('/api/legalgpt/extract/files-in-memory');
                const data = await response.json();
                
                const dropdown = document.getElementById('extract-file-select');
                if (!dropdown) return;
                
                // Clear and populate
                dropdown.innerHTML = '<option value="">-- Choose a file --</option>';
                
                if (data.status === 'success' && data.files && data.files.length > 0) {
                    data.files.forEach(filename => {
                        const option = document.createElement('option');
                        option.value = filename;
                        option.textContent = filename;
                        dropdown.appendChild(option);
                    });
                } else {
                    dropdown.innerHTML = '<option value="">No files in memory</option>';
                }
            } catch (e) {
                console.error('Failed to load extract files:', e);
            }
        }

        // Extract terms from selected file
        async function extractTermsFromMemory() {
            const dropdown = document.getElementById('extract-file-select');
            const filename = dropdown.value;
            
            if (!filename) {
                alert('Please select a file from the dropdown');
                return;
            }
            
            const resultsContainer = document.getElementById('extract-results');
            resultsContainer.innerHTML = '<div class="loading"><i class="fas fa-spinner fa-spin"></i> Extracting terms using AI...</div>';
            
            try {
                const response = await fetch('/api/legalgpt/extract/from-memory', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ filename: filename })
                });
                
                const data = await response.json();
                console.log('Extraction response:', data);
                
                if (data.status === 'success') {
                    console.log('Terms found:', data.terms ? data.terms.length : 0);
                    displayExtractionResultsFromMemory(data);
                } else {
                    console.error('Extraction failed:', data);
                    resultsContainer.innerHTML = `
                        <div class="error">
                            <i class="fas fa-exclamation-triangle"></i>
                            <p>Extraction failed: ${data.detail || 'Unknown error'}</p>
                        </div>
                    `;
                }
            } catch (e) {
                console.error('Extraction error:', e);
                resultsContainer.innerHTML = `
                    <div class="error">
                        <i class="fas fa-exclamation-triangle"></i>
                        <p>Extraction failed: ${e.message}</p>
                        <p class="error-details">Check console for details</p>
                    </div>
                `;
            }
        }

        function formatFieldName(fieldName) {
            if (!fieldName || fieldName === 'N/A') return 'N/A';
            
            // Convert snake_case to Title Case
            let formatted = fieldName
                .split('_')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
                .join(' ');
            
            // Words that should be pluralized (easily extensible list)
            const pluralizableWords = new Set([
                'clause', 'term', 'condition', 'provision', 'obligation', 
                'requirement', 'date', 'period', 'fee', 'charge', 'penalty',
                'warranty', 'guarantee', 'indemnity', 'liability', 'right',
                'duty', 'responsibility', 'restriction', 'limitation', 'notice',
                'document', 'agreement', 'contract', 'section', 'article'
            ]);
            
            // Handle special cases first (exact matches that override pluralization)
            const specialCases = {
                'effective date': 'Effective date',
                'expiration date': 'Expiration date',
                'renewal date': 'Renewal date',
                'termination date': 'Termination date',
                'payment terms': 'Payment terms',
                'governing law': 'Governing law',
                'jurisdiction': 'Jurisdiction',
                'counterparty': 'Counterparty',
                'party': 'Party',
                'parties': 'Parties',
            };
            
            const lowerFormatted = formatted.toLowerCase();
            if (specialCases[lowerFormatted]) {
                return specialCases[lowerFormatted];
            }
            
            // Check if last word should be pluralized
            const words = formatted.split(' ');
            if (words.length > 0) {
                const lastWord = words[words.length - 1].toLowerCase();
                // Only pluralize if word is in our list and not already pluralized
                if (pluralizableWords.has(lastWord) && !lastWord.endsWith('(s)')) {
                    words[words.length - 1] = words[words.length - 1] + '(s)';
                    formatted = words.join(' ');
                }
            }
            
            return formatted;
        }

        function displayExtractionResultsFromMemory(data) {
            const resultsContainer = document.getElementById('extract-results');
            const terms = data.terms || [];
            const sentiment = data.sentiment || null;
            
            // Debug logging
            console.log('displayExtractionResultsFromMemory - terms count:', terms.length);
            console.log('displayExtractionResultsFromMemory - terms data:', terms);
            
            if (terms.length === 0) {
                console.warn('WARNING: No terms in data.terms array - table will be empty!');
            }
            
            let html = `
                <div class="extraction-results-header">
                    <h3><i class="fas fa-file-contract"></i> Extracted Terms from ${data.filename}</h3>
                    <p>${terms.length} key terms identified</p>
                </div>
            `;
            
            // Add sentiment score card if available
            if (sentiment) {
                const score = sentiment.score || 50;
                const label = sentiment.label || 'Needs Review';
                const explanation = sentiment.explanation || '';
                const concerns = sentiment.concerns || [];
                const positives = sentiment.positives || [];
                
                // Determine color class based on score
                let scoreClass = 'sentiment-yellow';
                if (score >= 70) {
                    scoreClass = 'sentiment-green';
                } else if (score < 40) {
                    scoreClass = 'sentiment-red';
                }
                
                html += `
                    <div class="sentiment-score-card ${scoreClass}">
                        <div class="sentiment-score-header">
                            <div class="sentiment-score-main">
                                <div class="sentiment-score-value">${score}</div>
                                <div class="sentiment-score-label">${label}</div>
                            </div>
                            <div class="sentiment-score-icon">
                                ${score >= 70 ? '<i class="fas fa-check-circle"></i>' : 
                                  score >= 40 ? '<i class="fas fa-exclamation-triangle"></i>' : 
                                  '<i class="fas fa-times-circle"></i>'}
                            </div>
                        </div>
                        <div class="sentiment-score-explanation">
                            ${explanation}
                        </div>
                        ${concerns.length > 0 ? `
                            <div class="sentiment-concerns">
                                <strong>Key Concerns:</strong>
                                <ul>
                                    ${concerns.map(c => `<li>${c}</li>`).join('')}
                                </ul>
                            </div>
                        ` : ''}
                        ${positives.length > 0 ? `
                            <div class="sentiment-positives">
                                <strong>Positive Aspects:</strong>
                                <ul>
                                    ${positives.map(p => `<li>${p}</li>`).join('')}
                                </ul>
                            </div>
                        ` : ''}
                    </div>
                `;
            }
            
            html += `
                <div class="extraction-table">
                    <table>
                        <thead>
                            <tr>
                                <th>Field</th>
                                <th>Value</th>
                                <th>Snippet</th>
                                <th>Location</th>
                                <th>Confidence</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            if (terms.length === 0) {
                html += `
                    <tr>
                        <td colspan="5" style="text-align: center; padding: 2rem; color: var(--text-secondary);">
                            <i class="fas fa-info-circle"></i> No terms extracted. Check console logs for details.
                        </td>
                    </tr>
                `;
            } else {
                terms.forEach(term => {
                    if (!term || typeof term !== 'object') {
                        console.warn('Invalid term object:', term);
                        return;
                    }
                    const confidence = typeof term.confidence === 'number' ? (term.confidence * 100).toFixed(0) + '%' : 'N/A';
                    const formattedField = formatFieldName(term.field || 'Unknown');
                    html += `
                        <tr>
                            <td><strong>${formattedField}</strong></td>
                            <td>${term.value || 'Not found'}</td>
                            <td style="font-size: 0.85rem; font-style: italic;">${term.snippet || 'N/A'}</td>
                            <td>${term.location || 'N/A'}</td>
                            <td>${confidence}</td>
                        </tr>
                    `;
                });
            }
            
            html += `
                        </tbody>
                    </table>
                </div>
            `;
            
            resultsContainer.innerHTML = html;
            
            // Store results for CSV export (convert terms format to exportable format)
            window.extractionResults = {
                filename: data.filename,
                terms: terms,
                sentiment: sentiment
            };
            
            // Show export button
            document.getElementById('extract-actions').style.display = 'flex';
        }

        // New Search Functions (using grouped results + AI summaries)
        // Helper function to escape HTML
        function escapeHtml(str) {
            return String(str || '')
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        async function performSearch() {
            const query = document.getElementById('search-input').value.trim();
            const resultsContainer = document.getElementById('search-results');
            
            if (!query) {
                alert('Please enter a search query');
                return;
            }
            
            // Show loading state
            resultsContainer.innerHTML = '<div class="loading"><i class="fas fa-spinner fa-spin"></i> Searching clauses and documents...</div>';
            
            try {
                const response = await fetch('/api/search/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ 
                        query,
                        top_k_groups: 6,
                        max_snippets_per_group: 3,
                        enable_clause_summaries: false
                    })
                });
                
                if (!response.ok) {
                    // Try to get error details from response
                    let errorMessage = `Search failed: ${response.statusText}`;
                    try {
                        const errorData = await response.json();
                        errorMessage = errorData.detail || errorMessage;
                    } catch (e) {
                        // If JSON parsing fails, use status text
                    }
                    throw new Error(errorMessage);
                }
                
                const data = await response.json();
                console.log('Search response:', data); // Debug log
                renderSearchResults(data);
                
            } catch (error) {
                console.error('Search error:', error);
                const errorMessage = error.message || 'Sorry, something went wrong while searching. Please try again.';
                renderSearchError(errorMessage);
            }
        }

        function renderSearchResults(data) {
            const container = document.getElementById('search-results');
            
            if (!data) {
                renderSearchError('Search failed. Please try again.');
                return;
            }
            
            const { overall_summary, total_matches, files } = data;
            
            if (!files || files.length === 0) {
                container.innerHTML = `
                    <div class="no-results">
                        <i class="fas fa-file-search"></i>
                        <p>No matching clauses or documents were found for this query.</p>
                        <p class="hint">Try different keywords or check your spelling</p>
                    </div>
                `;
                return;
            }
            
            let html = '';
            
            // Overall summary (if any)
            if (overall_summary && overall_summary.trim()) {
                html += `
                    <div class="search-summary">
                        <div class="summary-icon"><i class="fas fa-lightbulb"></i></div>
                        <div class="summary-text">${escapeHtml(overall_summary)}</div>
                    </div>
                `;
            }
            
            // File groups
            files.forEach((file) => {
                const safeFileName = escapeHtml(file.file_name || 'Unknown document');
                const docScore = typeof file.doc_score === 'number' ? file.doc_score.toFixed(2) : '‚Äì';
                
                // Pick a quality class based on doc_score
                let qualityClass = 'quality-fair';
                if (file.doc_score >= 0.75) qualityClass = 'quality-excellent';
                else if (file.doc_score >= 0.5) qualityClass = 'quality-good';
                
                html += `
                    <div class="search-file-group">
                        <div class="group-header">
                            <div class="group-filename">
                                <i class="fas fa-file-contract"></i>
                                <div>
                                    <div><strong>${safeFileName}</strong></div>
                                    ${file.file_path ? `<div class="file-path-text">${escapeHtml(file.file_path)}</div>` : ''}
                                </div>
                            </div>
                            <div class="group-score search-quality ${qualityClass}">
                                Relevance: ${(parseFloat(docScore) * 100).toFixed(0)}% ${file.doc_score >= 0.75 ? '(High)' : file.doc_score >= 0.5 ? '(Good)' : '(Fair)'}
                            </div>
                        </div>
                `;
                
                // Always show keyword_summary (now guaranteed to be present)
                html += `
                    <div class="keyword-summary">
                        <div class="keyword-summary-icon"><i class="fas fa-info-circle"></i></div>
                        <div class="keyword-summary-text">${escapeHtml(file.keyword_summary || '')}</div>
                    </div>
                `;
                
                html += `<div class="group-snippets">`;
                
                // Group clauses by type
                const clausesByType = {};
                (file.clauses || []).forEach((clause) => {
                    const clauseType = clause.clause_type || 'Other';
                    if (!clausesByType[clauseType]) {
                        clausesByType[clauseType] = [];
                    }
                    clausesByType[clauseType].push(clause);
                });
                
                // Define clause type order
                const clauseTypeOrder = [
                    'Intro / Recitals',
                    'Term & Renewal',
                    'Termination',
                    'Payment',
                    'Confidentiality',
                    'Liability',
                    'Governing Law',
                    'Other'
                ];
                
                // Render clauses grouped by type
                clauseTypeOrder.forEach((clauseType) => {
                    const clausesOfType = clausesByType[clauseType];
                    if (!clausesOfType || clausesOfType.length === 0) return;
                    
                    // Add clause type header if there are multiple types
                    if (Object.keys(clausesByType).length > 1) {
                        html += `<div class="clause-type-header"><h4>${escapeHtml(clauseType)}</h4></div>`;
                    }
                    
                    clausesOfType.forEach((clause) => {
                        const heading = clause.section_title && clause.section_title.trim() ? clause.section_title.trim() : null;
                        const matchBadge = clause.match_type === 'semantic+keyword'
                            ? '<span class="badge badge-keyword">Keyword + Semantic</span>'
                            : '<span class="badge badge-semantic">Semantic match</span>';
                        // Use display_clause_score if available, otherwise similarity_score
                        const clauseScore = clause.display_clause_score !== undefined ? clause.display_clause_score : clause.similarity_score;
                        const scorePercent = typeof clauseScore === 'number' ? (clauseScore * 100).toFixed(0) : '‚Äì';
                        const summaryHtml = clause.clause_summary
                            ? `<div class="snippet-meta-line"><strong>Summary:</strong> ${escapeHtml(clause.clause_summary)}</div>`
                            : '';
                        
                        // Render clause_text as markdown, then maybe truncate
                        let snippetHtml = '';
                        if (typeof marked !== 'undefined' && marked.parse) {
                            snippetHtml = marked.parse(clause.clause_text || '');
                        } else {
                            snippetHtml = `<p>${escapeHtml(clause.clause_text || '')}</p>`;
                        }
                        
                        html += `
                            <div class="snippet-item">
                                <div class="snippet-header">
                                    <div class="snippet-title">
                                        ${heading ? `<strong>${escapeHtml(heading)}</strong>` : '<strong>Clause</strong>'}
                                    </div>
                                    <div class="snippet-badges">
                                        ${matchBadge}
                                        <span class="badge badge-score subtle-score">Top clause match: ${scorePercent}%</span>
                                    </div>
                                </div>
                                <div class="snippet-text">
                                    ${snippetHtml}
                                </div>
                                ${summaryHtml}
                                <div class="snippet-meta">
                                    ${clause.file_name ? `<span><i class="fas fa-file-alt"></i> ${escapeHtml(clause.file_name)}</span>` : ''}
                                    ${typeof clause.chunk_index === 'number' ? `<span><i class="fas fa-hashtag"></i> Clause #${clause.chunk_index}</span>` : ''}
                                    ${file.file_name ? `<span><i class="fas fa-external-link-alt"></i> <a href="/api/documents/${encodeURIComponent(file.file_name)}/download" target="_blank" rel="noopener noreferrer">Open document</a></span>` : ''}
                                </div>
                            </div>
                        `;
                    });
                });
                
                html += `</div></div>`; // close .group-snippets and .search-file-group
            });
            
            container.innerHTML = html;
        }
        
        function renderSearchError(message) {
            const container = document.getElementById('search-results');
            container.innerHTML = `
                <div class="error">
                    <i class="fas fa-exclamation-triangle"></i>
                    <p>${escapeHtml(message)}</p>
                </div>
            `;
        }

        function handleSearchKeyDown(event) {
            if (event.key === 'Enter') {
                performSearch();
            }
        }

        // LegalGPT Extract Functions
        function handleExtractFiles(input) {
            const files = Array.from(input.files);
            if (files.length === 0) return;
            
            const resultsContainer = document.getElementById('extract-results');
            const actionsContainer = document.getElementById('extract-actions');
            
            resultsContainer.innerHTML = '<div class="loading">Processing files...</div>';
            actionsContainer.style.display = 'none';
            
            extractContracts(files);
        }

        async function extractContracts(files) {
            const formData = new FormData();
            files.forEach(file => {
                formData.append('files', file);
            });
            
            try {
                const response = await fetch('/api/legalgpt/extract/', {
                    method: 'POST',
                    body: formData
                });
                
                const data = await response.json();
                
                if (data.status === 'success') {
                    displayExtractionResults(data.rows);
                    window.extractionResults = data.rows; // Store for CSV export
                    document.getElementById('extract-actions').style.display = 'block';
                } else {
                    throw new Error(data.detail || 'Extraction failed');
                }
            } catch (error) {
                console.error('Extraction error:', error);
                document.getElementById('extract-results').innerHTML = `
                    <div class="error">
                        <i class="fas fa-exclamation-triangle"></i>
                        <p>Extraction failed: ${error.message}</p>
                    </div>
                `;
            }
        }

        function displayExtractionResults(results) {
            const resultsContainer = document.getElementById('extract-results');
            
            let html = `
                <div class="extraction-results-header">
                    <h3>Extraction Results</h3>
                    <p>Processed ${results.length} files</p>
                </div>
                <div class="extraction-table">
                    <table>
                        <thead>
                            <tr>
                                <th>Filename</th>
                                <th>Counterparty</th>
                                <th>Effective Date</th>
                                <th>Expiration</th>
                                <th>Payment Terms</th>
                                <th>Status</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            results.forEach(result => {
                const status = result.error ? 'Error' : 'Success';
                const statusClass = result.error ? 'error' : 'success';
                
                html += `
                    <tr>
                        <td>${result.filename || 'Unknown'}</td>
                        <td>${result.counterparty || '-'}</td>
                        <td>${result.effective_date || '-'}</td>
                        <td>${result.expiration_or_renewal || '-'}</td>
                        <td>${result.payment_terms || '-'}</td>
                        <td><span class="status ${statusClass}">${status}</span></td>
                    </tr>
                `;
            });
            
            html += `
                        </tbody>
                    </table>
                </div>
            `;
            
            resultsContainer.innerHTML = html;
        }

        async function exportExtractionResults() {
            if (!window.extractionResults) {
                alert('No extraction results to export');
                return;
            }
            
            try {
                // Handle both formats: old format (rows array) and new format (terms object)
                let rowsToExport = [];
                
                if (Array.isArray(window.extractionResults)) {
                    // Old format: array of rows
                    rowsToExport = window.extractionResults;
                } else if (window.extractionResults.terms) {
                    // New format: terms array with filename
                    // Convert terms to row format for CSV export
                    const filename = window.extractionResults.filename || 'Unknown';
                    const terms = window.extractionResults.terms || [];
                    
                    // Create a single row with all terms as columns
                    const row = { filename: filename };
                    terms.forEach(term => {
                        const field = term.field || '';
                        const value = term.value || '';
                        // Convert field name to column name
                        if (field) {
                            row[field] = value;
                        }
                    });
                    rowsToExport = [row];
                } else {
                    alert('No extraction results to export');
                    return;
                }
                
                const response = await fetch('/api/legalgpt/extract/export', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ rows: rowsToExport })
                });
                
                if (response.ok) {
                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    const filename = window.extractionResults.filename || (window.extractionResults[0]?.filename) || 'contract_extraction';
                    const safeFilename = filename.replace(/[^a-z0-9]/gi, '_');
                    a.download = `${safeFilename}_${new Date().toISOString().slice(0, 10)}.csv`;
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);
                } else {
                    throw new Error('Export failed');
                }
            } catch (error) {
                console.error('Export error:', error);
                alert('Export failed. Please try again.');
            }
        }

        // LegalGPT Prompt Templates Functions
        async function loadPromptTemplates() {
            try {
                const response = await fetch('/api/legalgpt/prompts/');
                if (!response.ok) {
                    console.warn('Prompt templates endpoint not available');
                    return;
                }
                const data = await response.json();
                
                // Handle different response structures
                const templates = data.templates || data || [];
                if (Array.isArray(templates)) {
                    displayPromptTemplates(templates);
                } else {
                    console.warn('Invalid templates data format:', data);
                }
            } catch (error) {
                console.error('Failed to load prompt templates:', error);
                // Silently fail - prompt templates are optional
            }
        }

        function displayPromptTemplates(templates) {
            if (!templates || !Array.isArray(templates)) {
                console.warn('displayPromptTemplates called with invalid data:', templates);
                return;
            }
            
            const sidebarContainer = document.getElementById('prompt-templates');
            const modalContainer = document.getElementById('prompt-list');
            
            if (!modalContainer) {
                console.warn('Prompt template modal container not found');
                return;
            }
            
            // Sidebar container is optional (may be removed in minimal build)
            let sidebarHtml = '';
            let modalHtml = '';
            
            templates.forEach(template => {
                // Only generate sidebar HTML if container exists
                if (sidebarContainer) {
                    sidebarHtml += `
                        <div class="prompt-template-item" onclick="usePromptTemplate('${template.id}')">
                            <div class="prompt-label">${template.label}</div>
                            <div class="prompt-preview">${template.template.substring(0, 50)}...</div>
                        </div>
                    `;
                }
                
                modalHtml += `
                    <div class="prompt-editor-item">
                        <div class="prompt-editor-header">
                            <input type="text" value="${template.label}" class="prompt-label-input" data-id="${template.id}">
                            <button onclick="removePrompt('${template.id}')" class="btn-remove">
                                <i class="fas fa-trash"></i>
                            </button>
                        </div>
                        <textarea class="prompt-template-input" data-id="${template.id}">${template.template}</textarea>
                    </div>
                `;
            });
            
            // Only update sidebar if container exists
            if (sidebarContainer) {
                sidebarContainer.innerHTML = sidebarHtml;
            }
            modalContainer.innerHTML = modalHtml;
        }

        function usePromptTemplate(templateId) {
            // Find the template and use it in the current mode
            const templates = document.querySelectorAll('.prompt-template-item');
            templates.forEach(item => {
                if (item.onclick.toString().includes(templateId)) {
                    const preview = item.querySelector('.prompt-preview').textContent;
                    const fullTemplate = preview.replace('...', ''); // This is simplified
                    
                    // Use in current mode
                    const activeMode = document.querySelector('.mode-panel.active').id;
                    if (activeMode === 'chat-mode') {
                        document.getElementById('chat-input').value = fullTemplate;
                    } else if (activeMode === 'search-mode') {
                        document.getElementById('search-input').value = fullTemplate;
                    }
                }
            });
        }

        function showPromptEditor() {
            document.getElementById('prompt-editor-modal').classList.add('active');
        }

        function addNewPrompt() {
            const promptList = document.getElementById('prompt-list');
            const newId = 'new_prompt_' + Date.now();
            
            const newPromptHtml = `
                <div class="prompt-editor-item">
                    <div class="prompt-editor-header">
                        <input type="text" placeholder="Template label" class="prompt-label-input" data-id="${newId}">
                        <button onclick="removePrompt('${newId}')" class="btn-remove">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                    <textarea class="prompt-template-input" data-id="${newId}" placeholder="Enter your prompt template here..."></textarea>
                </div>
            `;
            
            promptList.insertAdjacentHTML('beforeend', newPromptHtml);
        }

        function removePrompt(templateId) {
            const item = document.querySelector(`[data-id="${templateId}"]`).closest('.prompt-editor-item');
            item.remove();
        }

        async function savePrompts() {
            const templates = [];
            const items = document.querySelectorAll('.prompt-editor-item');
            
            items.forEach(item => {
                const labelInput = item.querySelector('.prompt-label-input');
                const templateInput = item.querySelector('.prompt-template-input');
                
                if (labelInput.value.trim() && templateInput.value.trim()) {
                    templates.push({
                        id: labelInput.dataset.id,
                        label: labelInput.value.trim(),
                        template: templateInput.value.trim()
                    });
                }
            });
            
            try {
                const response = await fetch('/api/legalgpt/prompts/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ templates })
                });
                
                if (response.ok) {
                    alert('Prompts saved successfully!');
                    closeModal('prompt-editor-modal');
                    loadPromptTemplates(); // Reload the sidebar
                } else {
                    throw new Error('Save failed');
                }
            } catch (error) {
                console.error('Save error:', error);
                alert('Failed to save prompts. Please try again.');
            }
        }
    </script>
    <!-- Marked.js for markdown rendering -->
    <script src="https://cdn.jsdelivr.net/npm/marked@12.0.0/marked.min.js"></script>
    <script src="/static/app.js?v=1764782614"></script>
</body>
</html>

